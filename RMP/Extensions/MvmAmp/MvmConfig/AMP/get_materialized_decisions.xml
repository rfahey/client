<procs>

  <!-- ===================================================================== -->
  <!-- Inputs:                                                               -->
  <!--     id_acc             The account to process                         -->
  <!--     id_usage_interval  The interval we are interested in              -->
  <!--                                                                       -->
  <!-- This proc instantiates all the decisions that we are interested       -->
  <!-- in. The term "BUCKET" means decision instance.                        -->
  <!--                                                                       -->
  <!-- Results:                                                              -->
  <!--     AGG_BUCKETS_BY_ACCOUNT                                            -->
  <!--     AGG_BUCKETS_BY_PRIORITY                                           -->
  <!--     BUCKET_CHILDREN                                                   -->
  <!--     ACCOUNTS_BY_AGG_BUCKET                                            -->
  <!-- ===================================================================== -->

  <proc name="get_materialized_decisions">
    <param name='id_acc'/>
    <param name='id_usage_interval'/>

    <!-- Set up some structures that we need in the rest of the structure -->

    <initialize>



      <do>TEMP.my_counter = 0</do>
      <do>TEMP.my_pt_list = ''</do>

    </initialize>

    <debug switch="log_materialize_decisions">'Instantiating all decisions needed for account '~TEMP.id_acc~', interval '~TEMP.id_usage_interval</debug>

    <index_clear>
      <index>'NAMES_BY_SUB'</index>
    </index_clear>
    <index_clear>
      <index>'PREVIOUS_DECISION_INFO'</index>
    </index_clear>
    <index_clear>
      <index>'PREVIOUS_DECISIONS'</index>
    </index_clear>
    <index_clear>
      <index>'PREVIOUS_DECISION_MAX'</index>
    </index_clear>

    <!-- We are going to instantiate all the decisions for the given interval -->
    <!-- for the given account.   For example, if the interval is a month     -->
    <!-- and the cycle unit type is daily, then there will be 31 decisions -->
    <!-- to instantiate.  These instantiated instances are called "buckets" -->

    <!-- Fill VALID_INTERVALS with all intervals in the database that aren't -->
    <!-- hard closed. -->
    <index_select>
      <index>'VALID_INTERVALS'</index>
      <field name="interval_id">TEMP.id_usage_interval</field>
      <cursor>TEMP.interval_cache</cursor>
      <then>
        <do>GLOBAL.id_usage_interval = OBJECT(TEMP.interval_cache).interval_id</do>
        <do>GLOBAL.interval_start_date = OBJECT(TEMP.interval_cache).start_date</do>
        <do>GLOBAL.interval_end_date = OBJECT(TEMP.interval_cache).end_date</do>
      </then>
      <else>
        <db_select>
          <login_object>GLOBAL.target_login</login_object>
          <query>
            "SELECT a.* FROM t_usage_interval a
            WHERE a.id_interval = $${TEMP.id_usage_interval} and tx_interval_status != 'H'"
          </query>
          <cursor>TEMP.interval_csr</cursor>
          <then>
            <do>GLOBAL.id_usage_interval = OBJECT(TEMP.interval_csr).id_interval</do>
            <do>GLOBAL.interval_start_date = OBJECT(TEMP.interval_csr).dt_start</do>
            <do>GLOBAL.interval_end_date = OBJECT(TEMP.interval_csr).dt_end</do>
            <index_insert>
              <index>'VALID_INTERVALS'</index>
              <field name="interval_id">OBJECT(TEMP.interval_csr).id_interval</field>
              <field name="start_date">OBJECT(TEMP.interval_csr).dt_start</field>
              <field name="end_date">OBJECT(TEMP.interval_csr).dt_end</field>
            </index_insert>
          </then>
          <else>
            <severe>'Unable to find open interval '~TEMP.id_usage_interval</severe>
            <fatal>'Shutting down.'</fatal>
          </else>
        </db_select>
      </else>
    </index_select>

    <!-- In order to create the decisions, we need to know where our last -->
    <!-- decision from the previous interval left off.  For example, if our -->
    <!-- decision cycle is every 4 days, we'd need to know what was the ending -->
    <!-- date of the last decision in the previous interval.  We figure this out -->
    <!-- by looking in audit information. -->
    <debug>'We need to determine where our last decisions from the previous interval left off.'</debug>
    <debug>'This gives us the ending date of the last decision in the previous interval.'</debug>
    <debug>'This is important in scenarios such as: the decision is 4 days long, but the interval is a month.'</debug>
    <db_select>
      <login_object>GLOBAL.target_login</login_object>
      <query type="sql">
        "SELECT c.* FROM t_usage_interval a
        INNER JOIN t_usage_interval b on DATEADD(ss,-1,a.dt_start) = b.dt_end
        AND a.id_usage_cycle = b.id_usage_cycle
        INNER JOIN agg_decision_audit_trail c on b.id_interval = c.id_usage_interval and c.id_acc = $${TEMP.id_acc} and (c.expired != '1' or c.expired IS NULL)
        WHERE a.id_interval = $${TEMP.id_usage_interval}"
      </query>
      <query type="oracle">
        "SELECT c.* FROM t_usage_interval a
        INNER JOIN t_usage_interval b on sysdate - 1/86400 = b.dt_end
        AND a.id_usage_cycle = b.id_usage_cycle
        INNER JOIN agg_decision_audit_trail c on b.id_interval = c.id_usage_interval and c.id_acc = $${TEMP.id_acc} and (c.expired != '1' or c.expired IS NULL)
        WHERE a.id_interval = $${TEMP.id_usage_interval}"
      </query>
      <cursor>TEMP.decision_history_csr</cursor>
      <loop>
        <if>
          <condition>OBJECT(TEMP.decision_history_csr).audit_only ne '1'</condition>
          <then>
            <!--<print>'INSERTING P_D_I: ['~OBJECT(TEMP.decision_history_csr).decision_unique_id~']['~OBJECT(TEMP.decision_history_csr).qualified_amount~']['~OBJECT(TEMP.decision_history_csr).end_date~']['~OBJECT(TEMP.decision_history_csr).qualified_amount~']'</print>-->
            <index_insert>
              <index>'PREVIOUS_DECISION_INFO'</index>
              <field name="decision_object_id">OBJECT(TEMP.decision_history_csr).decision_object_id</field>
              <field name="decision_unique_id">OBJECT(TEMP.decision_history_csr).decision_unique_id</field>
              <field name="start_date">OBJECT(TEMP.decision_history_csr).start_date</field>
              <field name="end_date">OBJECT(TEMP.decision_history_csr).end_date</field>
              <field name="intervals_remaining">OBJECT(TEMP.decision_history_csr).intervals_remaining</field>
              <field name="expiration_date">OBJECT(TEMP.decision_history_csr).expiration_date</field>
              <field name="expired">OBJECT(TEMP.decision_history_csr).expired</field>
              <field name="pre_qualified_amount">OBJECT(TEMP.decision_history_csr).qualified_amount</field>
              <field name="pre_qualified_units">OBJECT(TEMP.decision_history_csr).qualified_units</field>
              <field name="pre_qualified_events">OBJECT(TEMP.decision_history_csr).qualified_events</field>
              <field name="pre_total_generated_events">OBJECT(TEMP.decision_history_csr).total_generated_events</field>
              <field name="pre_total_generated_amount">OBJECT(TEMP.decision_history_csr).total_generated_amount</field>
              <field name="pre_total_rated_amount_delta">OBJECT(TEMP.decision_history_csr).total_rated_amount_delta</field>
              <field name="pre_total_rated_units">OBJECT(TEMP.decision_history_csr).total_rated_units</field>
              <field name="pre_total_rated_amount_after">OBJECT(TEMP.decision_history_csr).total_rated_amount_after</field>
              <field name="pre_total_rated_events">OBJECT(TEMP.decision_history_csr).total_rated_events</field>
              <field name="pre_total_discount_amount">OBJECT(TEMP.decision_history_csr).total_discount_amount</field>
              <field name="pre_total_discounted_amount">OBJECT(TEMP.decision_history_csr).total_discounted_amount</field>
              <field name="pre_total_discounted_units">OBJECT(TEMP.decision_history_csr).total_discounted_units</field>
              <field name="pre_total_discounted_events">OBJECT(TEMP.decision_history_csr).total_discounted_events</field>
            </index_insert>
            <index_insert>
              <index>'PREVIOUS_DECISIONS'</index>
              <field name="decision_unique_id">OBJECT(TEMP.decision_history_csr).decision_unique_id</field>
              <field name="start_date">OBJECT(TEMP.decision_history_csr).start_date</field>
              <field name="end_date">OBJECT(TEMP.decision_history_csr).end_date</field>
              <field name="intervals_remaining">OBJECT(TEMP.decision_history_csr).intervals_remaining</field>
            </index_insert>
          </then>
        </if>

        <!-- Figure out the decision with the latest end date. -->
        <do>TEMP.replace = '0'</do>
        <index_select>
          <index>'PREVIOUS_DECISION_MAX'</index>
          <field name="decision_unique_id">OBJECT(TEMP.decision_history_csr).decision_unique_id</field>
          <cursor>TEMP.decision_max</cursor>
          <then>
            <if>
              <condition>OBJECT(TEMP.decision_history_csr).end_date gt OBJECT(TEMP.decision_max).end_date</condition>
              <then>
                <do>TEMP.replace = 1</do>
              </then>
            </if>
          </then>
          <else>
            <do>TEMP.replace = 1</do>
          </else>
        </index_select>
        <if>
          <condition>TEMP.replace == '1'</condition>
          <then>
            <index_remove>
              <index>'PREVIOUS_DECISION_MAX'</index>
              <field name="decision_unique_id">OBJECT(TEMP.decision_history_csr).decision_unique_id</field>
            </index_remove>
            <index_insert>
              <index>'PREVIOUS_DECISION_MAX'</index>
              <field name="decision_unique_id">OBJECT(TEMP.decision_history_csr).decision_unique_id</field>
              <field name="start_date">OBJECT(TEMP.decision_history_csr).start_date</field>
              <field name="end_date">OBJECT(TEMP.decision_history_csr).end_date</field>
              <field name="intervals_remaining">OBJECT(TEMP.decision_history_csr).intervals_remaining</field>
            </index_insert>
          </then>
        </if>
      </loop>
    </db_select>



    <db_select_dynamic>
      <login_object>GLOBAL.target_login</login_object>
      <query>
        'select * from agg_decision_info a where a.id_acc = $${TEMP.id_acc} and (a.end_date > $${GLOBAL.interval_start_date} or a.end_date IS NULL)
        and ($${GLOBAL.interval_end_date} > a.start_date or a.start_date IS NULL)'
      </query>
      <cursor>TEMP.decision_csr</cursor>
      <loop>
        <do>TEMP.my_bucket = OBJECT(TEMP.decision_csr).decision_object_id</do>
        <do>TEMP.keep_it = 1</do>

        <if>
          <condition>OBJECT(TEMP.my_bucket).eop_only eq '1' and GLOBAL.eop_mode ne '1'</condition>
          <then>
            <do>OBJECT(TEMP.my_bucket).discard_decision = '1'</do>
          </then>
        </if>

        <if>
          <condition>OBJECT(TEMP.my_bucket).discard_decision ne '1'</condition>
          <then>
            <do>OBJECT(TEMP.my_bucket).id_usage_interval = TEMP.id_usage_interval</do>
            <do>OBJECT(TEMP.my_bucket).interval_start_date = GLOBAL.interval_start_date</do>
            <do>OBJECT(TEMP.my_bucket).interval_end_date = GLOBAL.interval_end_date</do>
            <if>
              <condition>OBJECT(TEMP.my_bucket).tier_type Eq 'bulk'</condition>
              <then>
                <!--<do>OBJECT(TEMP.my_bucket).tier_priority += 1</do>-->
                <do>OBJECT(TEMP.my_bucket).tier_type = 'bulk_aggregate'</do>
              </then>
            </if>
            <!--<print>'JONAH ['~OBJECT(TEMP.my_bucket).cycle_unit_type~'] here starting to add the interval logic/date logic for multiple instances of the same counter'</print>-->
            <if>
              <condition>OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'interval' </condition>
              <then>
                <do>OBJECT(TEMP.my_bucket).orig_start_date = OBJECT(TEMP.my_bucket).start_date</do>
                <do>OBJECT(TEMP.my_bucket).orig_end_date = OBJECT(TEMP.my_bucket).end_date</do>
                <string_to_date>
                  <input format='YYYYMMDDHH24MISS'>'19700101000000'</input>
                  <output>OBJECT(TEMP.my_bucket).start_date</output>
                </string_to_date>
                <string_to_date>
                  <input format='YYYYMMDDHH24MISS'>'20380101000000'</input>
                  <output>OBJECT(TEMP.my_bucket).end_date</output>
                </string_to_date>
                <string_to_date>
                  <input format='YYYYMMDDHH24MISS'>'20380101000000'</input>
                  <output>OBJECT(TEMP.my_bucket).expiration_date</output>
                </string_to_date>
                <do>OBJECT(TEMP.my_bucket).id_usage_interval = TEMP.id_usage_interval</do>
                <!--<print>'Trying to overlay decision history with ['~OBJECT(TEMP.my_bucket).cycle_units_per_tier~']'</print>-->
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycle_units_per_tier GT '1'</condition>
                  <then>
                    <do>OBJECT(TEMP.my_bucket).intervals_remaining = OBJECT(TEMP.my_bucket).cycle_units_per_tier - 1</do>
                    <call_proc_for_current_object>
                      <name>'overlay_decision_history'</name>
                      <param name='my_bucket'>TEMP.my_bucket</param>
                    </call_proc_for_current_object>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).orig_start_date gt GLOBAL.interval_start_date</condition>
                  <then>
                    <do>OBJECT(TEMP.my_bucket).prorate_start_date = GLOBAL.interval_start_date</do>
                    <do>OBJECT(TEMP.my_bucket).prorate_end_date = GLOBAL.interval_end_date</do>
                    <do>OBJECT(TEMP.my_bucket).start_date = OBJECT(TEMP.my_bucket).orig_start_date</do>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).orig_end_date lt GLOBAL.interval_end_date</condition>
                  <then>
                    <do>OBJECT(TEMP.my_bucket).prorate_start_date = GLOBAL.interval_start_date</do>
                    <do>OBJECT(TEMP.my_bucket).prorate_end_date = GLOBAL.interval_end_date</do>
                    <do>OBJECT(TEMP.my_bucket).end_date = OBJECT(TEMP.my_bucket).orig_end_date</do>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).prorate_start_date ne ''</condition>
                  <then>
                    <call_proc_for_current_object>
                      <name>'prorate_bucket'</name>
                      <param name='my_bucket'>TEMP.my_bucket</param>
                    </call_proc_for_current_object>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycles gt '0'</condition>
                  <then>
                    <run_once>
                      <define_memory_index>
                        <index>'INTERVAL_GAPS'</index>
                        <key_field>'id_usage_interval'</key_field>
                        <key_field type='search'>'start_date'</key_field>
                        <field>'intervals_between'</field>
                      </define_memory_index>
                    </run_once>
                    <index_select>
                      <index>'INTERVAL_GAPS'</index>
                      <field name="id_usage_interval">TEMP.id_usage_interval</field>
                      <field name="start_date">OBJECT(TEMP.my_bucket).orig_start_date</field>
                      <cursor>TEMP.gaps_cur</cursor>
                      <then>
                        <do>TEMP.intervals_between = OBJECT(TEMP.gaps_cur).intervals_between</do>
                      </then>
                      <else>
                        <db_select>
                          <login_object>GLOBAL.target_login</login_object>
                          <query>
                            "select a.id_interval, b.dt_start, count(*) intervals_between from
                            t_usage_interval a
                            inner join t_usage_interval b on a.id_usage_cycle = b.id_usage_cycle and a.dt_start >= b.dt_start
                            inner join t_usage_interval c on b.id_usage_cycle = c.id_usage_cycle and c.dt_start >= b.dt_start and a.dt_start >= c.dt_start
                            where a.id_interval = $${TEMP.id_usage_interval}
                            group by a.id_interval, b.dt_start"
                          </query>
                          <cursor>TEMP.interval_gaps</cursor>
                          <loop>
                            <index_insert>
                              <index>'INTERVAL_GAPS'</index>
                              <field name='id_usage_interval'>OBJECT(TEMP.interval_gaps).id_interval</field>
                              <field name='start_date'>OBJECT(TEMP.interval_gaps).dt_start</field>
                              <field name='intervals_between'>OBJECT(TEMP.interval_gaps).intervals_between</field>
                            </index_insert>
                          </loop>
                        </db_select>
                        <index_select>
                          <index>'INTERVAL_GAPS'</index>
                          <field name="id_usage_interval">TEMP.id_usage_interval</field>
                          <field name="start_date">OBJECT(TEMP.my_bucket).orig_start_date</field>
                          <cursor>TEMP.inner_gaps_cur</cursor>
                          <then>
                            <do>TEMP.intervals_between = OBJECT(TEMP.inner_gaps_cur).intervals_between</do>
                          </then>
                        </index_select>
                      </else>
                    </index_select>
                    <do>TEMP.max_intervals_possible = OBJECT(TEMP.my_bucket).cycles * OBJECT(TEMP.my_bucket).cycle_units_per_tier + OBJECT(TEMP.my_bucket).cycle_unit_offset</do>
                    <if>
                      <condition>TEMP.max_intervals_possible LT TEMP.intervals_between</condition>
                      <then>
                        <do>TEMP.keep_it = '0'</do>
                      </then>
                    </if>
                  </then>
                </if>
              </then>
            </if>
            <if>
              <condition>OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'monthly' or OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'weekly' or OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'daily' or OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'quarterly' or OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'annually'</condition>
              <then>
                <do>OBJECT(TEMP.my_bucket).id_usage_interval = TEMP.id_usage_interval</do>
                <do>OBJECT(TEMP.my_bucket).orig_start_date = OBJECT(TEMP.my_bucket).start_date</do>
                <do>OBJECT(TEMP.my_bucket).orig_end_date = OBJECT(TEMP.my_bucket).end_date</do>
                <do>TEMP.cycles_back = 0 - OBJECT(TEMP.my_bucket).cycles</do>
                <do>TEMP.cycles = OBJECT(TEMP.my_bucket).cycles</do>
                <do>TEMP.cycle_units_per_tier = OBJECT(TEMP.my_bucket).cycle_units_per_tier</do>
                <do>TEMP.cycle_unit_offset = OBJECT(TEMP.my_bucket).cycle_unit_offset</do>
                <do>TEMP.unit = 'MM'</do>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'quarterly'</condition>
                  <then>
                    <do>TEMP.cycles_back = TEMP.cycles_back * 3</do>
                    <do>TEMP.cycles = TEMP.cycles * 3</do>
                    <do>TEMP.cycle_units_per_tier = TEMP.cycle_units_per_tier * 3</do>
                    <do>TEMP.cycle_unit_offset = TEMP.cycle_unit_offset * 3</do>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'annually'</condition>
                  <then>
                    <do>TEMP.cycles_back = TEMP.cycles_back * 12</do>
                    <do>TEMP.cycles = TEMP.cycles * 12</do>
                    <do>TEMP.cycle_units_per_tier = TEMP.cycle_units_per_tier * 12</do>
                    <do>TEMP.cycle_unit_offset = TEMP.cycle_unit_offset * 12</do>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'daily'</condition>
                  <then>
                    <do>TEMP.unit = 'DD'</do>
                  </then>
                </if>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycle_unit_type Eq 'weekly'</condition>
                  <then>
                    <do>TEMP.unit = 'DD'</do>
                    <do>TEMP.cycles_back = TEMP.cycles_back * 7</do>
                    <do>TEMP.cycles = TEMP.cycles * 7</do>
                    <do>TEMP.cycle_units_per_tier = TEMP.cycle_units_per_tier * 7</do>
                    <do>TEMP.cycle_unit_offset = TEMP.cycle_unit_offset * 7</do>
                  </then>
                </if>
                <date_add>
                  <input>GLOBAL.interval_start_date</input>
                  <unit>TEMP.unit</unit>
                  <increment>TEMP.cycles_back</increment>
                  <output>TEMP.earliest_possible_start</output>
                </date_add>
                <if>
                  <condition>OBJECT(TEMP.my_bucket).cycles eq '0'</condition>
                  <then>
                    <string_to_date>
                      <input format='YYYYMMDDHH24MISS'>'19700101000000'</input>
                      <output>TEMP.earliest_possible_start</output>
                    </string_to_date>
                    <string_to_date>
                      <input format='YYYYMMDDHH24MISS'>'20380101000000'</input>
                      <output>TEMP.latest_possible_end</output>
                    </string_to_date>
                  </then>
                  <else>
                    <do>TEMP.cycle_multiplier = TEMP.cycles * TEMP.cycle_units_per_tier + TEMP.cycle_unit_offset</do>
                    <date_add>
                      <input>OBJECT(TEMP.my_bucket).start_date</input>
                      <unit>TEMP.unit</unit>
                      <increment>TEMP.cycle_multiplier</increment>
                      <output>TEMP.latest_possible_end</output>
                    </date_add>
                  </else>
                </if>

                <index_select>
                  <index>'PREVIOUS_DECISION_MAX'</index>
                  <field name="decision_unique_id">OBJECT(TEMP.my_bucket).decision_unique_id</field>
                  <cursor>TEMP.prev_decisions</cursor>
                  <then>
                    <do>OBJECT(TEMP.my_bucket).start_date = OBJECT(TEMP.prev_decisions).end_date</do>
                  </then>
                  <else>
                    <date_add>
                      <input>OBJECT(TEMP.my_bucket).start_date</input>
                      <unit>TEMP.unit</unit>
                      <increment>TEMP.cycle_unit_offset</increment>
                      <output>OBJECT(TEMP.my_bucket).start_date</output>
                    </date_add>
                    <c>If I have no previous decision and the latest end date is prior to my interval and  </c>
                    <c>the tt_start is prior to the interval start date then I assume the decision has run its course so prevent any spawning of decisions</c>
                    <if>
                      <condition>TEMP.latest_possible_end lt GLOBAL.interval_start_date and OBJECT(TEMP.my_bucket).tt_start lt GLOBAL.interval_start_date</condition>
                      <then>
                        <string_to_date>
                          <input format='YYYYMMDDHH24MISS'>'19700101000000'</input>
                          <output>TEMP.latest_possible_end</output>
                        </string_to_date>
                      </then>
                    </if>
                  </else>
                </index_select>
                <!--<print>'Checking for previous decisions for ['~OBJECT(TEMP.my_bucket).decision_unique_id~']'</print>-->
                <index_select>
                  <index>'PREVIOUS_DECISIONS'</index>
                  <field name="decision_unique_id">OBJECT(TEMP.my_bucket).decision_unique_id</field>
                  <cursor>TEMP.prev_decisions</cursor>
                  <loop>
                    <print>'CALLING1 CREATE CHILD DECISION FOR id_acc ['~TEMP.id_acc~']'</print>
                    <call_proc_for_current_object>
                      <name>'create_child_decision'</name>
                      <param name='bucket_object'>TEMP.my_bucket</param>
                      <param name='bucket_overlay'>GLOBAL.calendar_overlay_object_id</param>
                      <param name='new_bucket_object'>TEMP.my_new_bucket</param>
                      <param name='delta_tracking_available'>0</param>
                      <param name='delta_tracking_on'>0</param>
                    </call_proc_for_current_object>
                    <print>'CALLING2 CREATE CHILD DECISION FOR id_acc ['~TEMP.id_acc~']'</print>
                    <do>OBJECT(TEMP.my_new_bucket).start_date = OBJECT(TEMP.prev_decisions).start_date</do>
                    <do>OBJECT(TEMP.my_new_bucket).end_date = OBJECT(TEMP.prev_decisions).end_date</do>
                    <do>OBJECT(TEMP.my_new_bucket).decision_unique_id = OBJECT(TEMP.prev_decisions).decision_unique_id</do>
                    <!--<print>'Trying to overlay decision history calendar!'</print>-->

                    <!--<print>'NOW Creating pre-existing child for ['~OBJECT(TEMP.prev_decisions).decision_unique_id~']['~OBJECT(TEMP.prev_decisions).start_date~']['~OBJECT(TEMP.prev_decisions).end_date~']'</print>-->
                    <call_proc_for_current_object>
                      <name>'overlay_decision_history'</name>
                      <param name='my_bucket'>TEMP.my_new_bucket</param>
                    </call_proc_for_current_object>
                    <if>
                      <condition>OBJECT(TEMP.my_new_bucket).end_date gt OBJECT(TEMP.my_bucket).orig_end_date</condition>
                      <then>
                        <do>OBJECT(TEMP.my_new_bucket).prorate_start_date = OBJECT(TEMP.my_new_bucket).start_date</do>
                        <do>OBJECT(TEMP.my_new_bucket).prorate_end_date = OBJECT(TEMP.my_new_bucket).end_date</do>
                        <do>OBJECT(TEMP.my_new_bucket).end_date = OBJECT(TEMP.my_bucket).orig_end_date</do>
                        <call_proc_for_current_object>
                          <name>'prorate_bucket'</name>
                          <param name='my_bucket'>TEMP.my_new_bucket</param>
                        </call_proc_for_current_object>
                      </then>
                    </if>
                  </loop>
                </index_select>
                <date_add>
                  <input>OBJECT(TEMP.my_bucket).start_date</input>
                  <unit>TEMP.unit</unit>
                  <increment>TEMP.cycle_units_per_tier</increment>
                  <output>OBJECT(TEMP.my_bucket).end_date</output>
                </date_add>
                <do>TEMP.start_date_to_keep = ''</do>
                <do>TEMP.end_date_to_keep = ''</do>
                <do>TEMP.current_matches = 0</do>
                <while>
                  <condition>OBJECT(TEMP.my_bucket).end_date lte TEMP.latest_possible_end and OBJECT(TEMP.my_bucket).start_date lte GLOBAL.interval_end_date and OBJECT(TEMP.my_bucket).start_date lt OBJECT(TEMP.my_bucket).orig_end_date</condition>
                  <loop>
                    <if>
                      <condition>OBJECT(TEMP.my_bucket).end_date gt TEMP.earliest_possible_start</condition>
                      <then>
                        <do>OBJECT(TEMP.my_bucket).prorate_start_date = ''</do>
                        <do>OBJECT(TEMP.my_bucket).prorate_end_date = ''</do>
                        <if>
                          <condition>OBJECT(TEMP.my_bucket).start_date lt OBJECT(TEMP.my_bucket).orig_start_date</condition>
                          <then>
                            <do>OBJECT(TEMP.my_bucket).prorate_start_date = OBJECT(TEMP.my_bucket).start_date</do>
                            <do>OBJECT(TEMP.my_bucket).prorate_end_date = OBJECT(TEMP.my_bucket).end_date</do>
                            <do>OBJECT(TEMP.my_bucket).start_date = OBJECT(TEMP.my_bucket).orig_start_date</do>
                          </then>
                        </if>
                        <if>
                          <condition>OBJECT(TEMP.my_bucket).end_date gt OBJECT(TEMP.my_bucket).orig_end_date</condition>
                          <then>
                            <do>OBJECT(TEMP.my_bucket).prorate_start_date = OBJECT(TEMP.my_bucket).start_date</do>
                            <do>OBJECT(TEMP.my_bucket).prorate_end_date = OBJECT(TEMP.my_bucket).end_date</do>
                            <do>OBJECT(TEMP.my_bucket).end_date = OBJECT(TEMP.my_bucket).orig_end_date</do>
                          </then>
                        </if>
                        <if>
                          <condition>TEMP.current_matches == 0</condition>
                          <then>
                            <do>TEMP.start_date_to_keep = OBJECT(TEMP.my_bucket).start_date</do>
                            <do>TEMP.end_date_to_keep = OBJECT(TEMP.my_bucket).end_date</do>
                            <do>TEMP.prorate_start_date_to_keep = OBJECT(TEMP.my_bucket).prorate_start_date</do>
                            <do>TEMP.prorate_end_date_to_keep = OBJECT(TEMP.my_bucket).prorate_end_date</do>
                          </then>
                          <else>
                            <!--<debug>'Creating child for ['~OBJECT(TEMP.my_bucket).start_date~']['~OBJECT(TEMP.my_bucket).end_date~']'</debug>-->

                            <print>'CALLING3 CREATE CHILD DECISION FOR id_acc ['~TEMP.id_acc~']'</print>
                            <call_proc_for_current_object>
                              <name>'create_child_decision'</name>
                              <param name='bucket_object'>TEMP.my_bucket</param>
                              <param name='bucket_overlay'>GLOBAL.calendar_overlay_object_id</param>
                              <param name='new_bucket_object'>TEMP.my_new_bucket</param>
                              <param name='delta_tracking_available'>0</param>
                              <param name='delta_tracking_on'>0</param>
                            </call_proc_for_current_object>
                            <print>'CALLING4 CREATE CHILD DECISION FOR id_acc ['~TEMP.id_acc~']'</print>
                            <if>
                              <condition>OBJECT(TEMP.my_new_bucket).prorate_start_date ne ''</condition>
                              <then>
                                <call_proc_for_current_object>
                                  <name>'prorate_bucket'</name>
                                  <param name='my_bucket'>TEMP.my_new_bucket</param>
                                </call_proc_for_current_object>
                              </then>
                            </if>
                            <do>OBJECT(TEMP.my_new_bucket).expiration_date = OBJECT(TEMP.my_new_bucket).end_date</do>
                            <!-- commenting this out because we want the decisions to expire on the end date until proven otherwise -->
                            <!--<date_add>
                                          <input>OBJECT(TEMP.my_new_bucket).end_date</input>
                                          <unit>TEMP.unit</unit>
                                          <increment>TEMP.cycles</increment>
                                          <increment>0</increment>
                                          <output>OBJECT(TEMP.my_new_bucket).expiration_date</output>
                                        </date_add>
                                        <if>
                                          <condition>TEMP.cycles eq '0'</condition>
                                          <then>
                                            <string_to_date>
                                              <input format='YYYYMMDDHH24MISS'>'20380101000000'</input>
                                              <output>OBJECT(TEMP.my_new_bucket).expiration_date</output>
                                            </string_to_date>
                                          </then>
                                        </if>-->
                            <do>OBJECT(TEMP.my_new_bucket).expired = '0'</do>
                          </else>
                        </if>
                        <do>TEMP.current_matches += 1</do>
                      </then>
                    </if>
                    <do>OBJECT(TEMP.my_bucket).start_date = OBJECT(TEMP.my_bucket).end_date</do>
                    <date_add>
                      <input>OBJECT(TEMP.my_bucket).start_date</input>
                      <unit>TEMP.unit</unit>
                      <increment>TEMP.cycle_units_per_tier</increment>
                      <output>OBJECT(TEMP.my_bucket).end_date</output>
                    </date_add>
                  </loop>
                </while>

                <if>
                  <condition>TEMP.current_matches GT 0</condition>
                  <then>
                    <do>OBJECT(TEMP.my_bucket).start_date = TEMP.start_date_to_keep</do>
                    <do>OBJECT(TEMP.my_bucket).end_date = TEMP.end_date_to_keep</do>
                    <do>OBJECT(TEMP.my_bucket).prorate_start_date = TEMP.prorate_start_date_to_keep</do>
                    <do>OBJECT(TEMP.my_bucket).prorate_end_date = TEMP.prorate_end_date_to_keep</do>
                    <do>OBJECT(TEMP.my_bucket).expiration_date = OBJECT(TEMP.my_bucket).end_date</do>
                    <!-- commenting this out because we want the decisions to expire on the end date until proven otherwise -->
                    <!--<date_add>
                                  <input>OBJECT(TEMP.my_bucket).end_date</input>
                                  <unit>TEMP.unit</unit>
                                  <increment>TEMP.cycles</increment>
                                  <output>OBJECT(TEMP.my_bucket).expiration_date</output>
                                </date_add>
                                <if>
                                  <condition>TEMP.cycles eq '0'</condition>
                                  <then>
                                    <string_to_date>
                                      <input format='YYYYMMDDHH24MISS'>'20380101000000'</input>
                                      <output>OBJECT(TEMP.my_bucket).expiration_date</output>
                                    </string_to_date>
                                  </then>
                                </if>-->
                    <do>OBJECT(TEMP.my_bucket).expired = '0'</do>
                    <if>
                      <condition>OBJECT(TEMP.my_bucket).prorate_start_date ne ''</condition>
                      <then>
                        <call_proc_for_current_object>
                          <name>'prorate_bucket'</name>
                          <param name='my_bucket'>TEMP.my_bucket</param>
                        </call_proc_for_current_object>
                      </then>
                    </if>
                  </then>
                  <else>
                    <do>TEMP.keep_it = 0</do>
                  </else>
                </if>
              </then>
            </if>

            <if>
              <condition>TEMP.keep_it == 1</condition>
              <then>


                <!--<index_insert>
                              <index>'AGG_BUCKET_MAP'</index>
                              <field name="bucket_object">OBJECT(TEMP.my_bucket).bucket_guid</field>
                              <field name="bucket_object">TEMP.my_bucket</field>
                            </index_insert>-->
                <index_insert>
                  <index>'NAMES_BY_SUB'</index>
                  <field name="id_sub">OBJECT(TEMP.rsched_csr).id_sub</field>
                  <field name="id_pi_instance">OBJECT(TEMP.rsched_csr).id_pi_instance</field>
                  <field name="tier_name">OBJECT(TEMP.my_bucket).tier_name</field>
                  <field name="id_sched">OBJECT(TEMP.pt_row_csr).id_sched</field>
                  <field name="n_order">OBJECT(TEMP.pt_row_csr).n_order</field>
                  <field name="start_date">OBJECT(TEMP.my_bucket).start_date</field>
                  <field name="end_date">OBJECT(TEMP.my_bucket).end_date</field>
                </index_insert>

                <!--<info>'1: ACCOUNTS_BY_AGG_BUCKET.insert('~OBJECT(TEMP.my_new_bucket).object_id~','~OBJECT(TEMP.child_accs).child_id_acc~')'</info>-->
                <if>
                  <condition>OBJECT(TEMP.my_bucket).tier_type Eq 'bulk_aggregate' and ((GLOBAL.split_bulk ne '1' and OBJECT(TEMP.my_bucket).split_bulk ne '1') or OBJECT(TEMP.my_bucket).split_bulk eq '0')</condition>
                  <then>
                    <do>TEMP.split_bulk_counter = ''</do>
                    <!--<print>'BulkSplit 1'</print>-->
                    <call_proc_for_current_object>
                      <name>'split_bulk_decision'</name>
                      <param name='bucket_object'>TEMP.my_bucket</param>
                      <param name='node_source_bucket_object'>TEMP.node_source_bucket_object</param>
                      <param name='node_target_bucket_object'>TEMP.node_target_bucket_object</param>
                      <param name='id_acc'>OBJECT(TEMP.my_bucket).id_acc</param>
                      <param name='node_id_acc'>OBJECT(TEMP.my_bucket).id_acc</param>
                      <param name='is_split_by_acc'>'0'</param>
                      <param name='split_bulk_counter'>TEMP.split_bulk_counter</param>
                    </call_proc_for_current_object>
                  </then>
                </if>

                <do>TEMP.split_bulk_counter = ''</do>
                <do>TEMP.node_target_bucket_object = ''</do>
                <do>TEMP.node_source_bucket_object = ''</do>
                <do>TEMP.node_id_acc = '-1'</do>
                <!--<print>'Looping through idacc ['~OBJECT(TEMP.my_bucket).id_acc~'] aqg ['~OBJECT(TEMP.my_bucket).account_qualification_group~']'</print>-->
                <index_select>
                  <index>'ACC_QUAL_GROUPS'</index>
                  <field name="id_acc">OBJECT(TEMP.my_bucket).id_acc</field>
                  <field name="group">OBJECT(TEMP.my_bucket).account_qualification_group</field>
                  <cursor>TEMP.child_accs</cursor>
                  <loop>
                    <!--<print>'With child id_acc ['~OBJECT(TEMP.child_accs).child_id_acc~']'</print>-->
                    <if>
                      <condition>OBJECT(TEMP.child_accs).child_id_acc ne ''</condition>
                      <then>
                        <!--<info>'2:ACCOUNTS_BY_AGG_BUCKET.insert('~OBJECT(TEMP.my_bucket).object_id~','~OBJECT(TEMP.child_accs).child_id_acc~'), TEMP.my_bucket='~TEMP.my_bucket</info>-->

                        <if>
                          <condition>TEMP.node_id_acc eq '-1'</condition>
                          <then>
                            <do>TEMP.node_id_acc = OBJECT(TEMP.child_accs).child_id_acc</do>
                          </then>
                        </if>
                        <index_insert>
                          <index>'ACCOUNTS_BY_AGG_BUCKET'</index>
                          <field name="bucket_object">OBJECT(TEMP.my_bucket).object_id</field>
                          <field name="id_acc">OBJECT(TEMP.child_accs).child_id_acc</field>
                        </index_insert>
                        <!--<print>'Inserting child acc ['~OBJECT(TEMP.child_accs).child_id_acc~'] for decision ['~OBJECT(TEMP.my_bucket).decision_unique_id~']'</print>-->
                        <index_insert>
                          <index>'AGG_BUCKETS_BY_ACCOUNT'</index>
                          <field name="bucket_object">OBJECT(TEMP.my_bucket).object_id</field>
                          <field name="id_acc">OBJECT(TEMP.child_accs).child_id_acc</field>
                        </index_insert>
                        <if>
                          <condition>((GLOBAL.split_bulk eq '1' and OBJECT(TEMP.my_bucket).split_bulk ne '0') or OBJECT(TEMP.my_bucket).split_bulk eq '1') and OBJECT(TEMP.my_bucket).tier_type Eq 'bulk_aggregate'</condition>
                          <then>
                            <!--<print>'BulkSplit 2'</print>-->
                            <call_proc_for_current_object>
                              <name>'split_bulk_decision'</name>
                              <param name='bucket_object'>TEMP.my_bucket</param>
                              <param name='node_source_bucket_object'>TEMP.node_source_bucket_object</param>
                              <param name='node_target_bucket_object'>TEMP.node_target_bucket_object</param>
                              <param name='id_acc'>OBJECT(TEMP.child_accs).child_id_acc</param>
                              <param name='node_id_acc'>TEMP.node_id_acc</param>
                              <param name='is_split_by_acc'>'1'</param>
                              <param name='split_bulk_counter'>TEMP.split_bulk_counter</param>
                            </call_proc_for_current_object>
                          </then>
                        </if>
                      </then>
                    </if>
                  </loop>
                </index_select>

                <!--<do>OBJECT(TEMP.my_bucket).decision_unique_id = OBJECT(TEMP.my_bucket).id_acc~'|'~OBJECT(TEMP.my_bucket).id_sub~'|'~OBJECT(TEMP.my_bucket).start_date~'|'~OBJECT(TEMP.my_bucket).id_po~'|'~OBJECT(TEMP.my_bucket).id_sched~'|'~OBJECT(TEMP.my_bucket).n_order~'|'~OBJECT(TEMP.my_bucket).tt_start~'|'~OBJECT(TEMP.my_bucket).tier_column_group~'|'~OBJECT(TEMP.my_bucket).tier_priority</do>-->
                <call_proc_for_object>
                  <name>'set_decision_unique_id'</name>
                  <object_id>TEMP.my_bucket</object_id>
                </call_proc_for_object>
                <!--<print>'DONE with idacc ['~OBJECT(TEMP.my_bucket).id_acc~'] aqg ['~OBJECT(TEMP.my_bucket).account_qualification_group~']'</print>-->
                <index_select>
                  <index>'ACCOUNTS_BY_AGG_BUCKET'</index>
                  <field name="bucket_object">OBJECT(TEMP.my_bucket).object_id</field>
                  <cursor>TEMP.child_accs</cursor>
                  <then>
                    <index_insert>
                      <index>'AGG_BUCKETS_BY_PRIORITY'</index>
                      <field name="bucket_object">OBJECT(TEMP.my_bucket).object_id</field>
                      <field name="tier_priority">OBJECT(TEMP.my_bucket).tier_priority</field>
                    </index_insert>
                  </then>
                </index_select>
              </then>
            </if>
          </then>
        </if>
      </loop>
    </db_select_dynamic>
  </proc>

</procs>
